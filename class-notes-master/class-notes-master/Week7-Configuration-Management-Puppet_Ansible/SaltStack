SALTSTACK
=========

    - SaltStack is an open-source configuration management and remote execution engine.
    - It remotely executes commands across all machines.
    - Like Ansible, SaltStack is written in Python
    - Opensource SaltStack is free
    - SaltStack uses the ZeroMQ messaging library to process high-speed requirements for all networking layers.

================================================================================================================================================================================================================================================
Installation & configuration
============================================================================

    - Add the repositories in both master and minions by running the following commands:

        $ wget -O - https://repo.saltstack.com/apt/ubuntu/18.04/amd64/latest/SALTSTACK-GPG-KEY.pub | sudo apt-key add -

        $ echo "deb http://repo.saltstack.com/apt/ubuntu/18.04/amd64/latest bionic main" | sudo tee /etc/apt/sources.list.d/saltstack.list

    - Salt-Master Installation:

        $ sudo apt -y install salt-api salt-cloud salt-master salt-minion salt-ssh salt-syndic

        $ sudo ufw allow proto tcp from any to any port 4505,4506

        $ sudo systemctl restart salt-master.service

    - Salt-Minion Installation:

        $ sudo apt install salt-minion

        - Set DNS name of the Salt Master on /etc/hosts

            <master-ip-address>   salt

        - Set Minion ID on /etc/salt/minion_id

            ubuntu-minion-01

        $ sudo systemctl restart salt-minion


    - Login to the master node and check Accepted Keys:

        $ salt-key -L

    - Accept the Key on the Master

        $ salt-key --accept='ubuntu-minion-01'

    - You can also accept for all of the Minion servers by using the option -A

        $ salt-key -A


Validation
----------

    - Check Minion Key Fingerprint

        - Run the following command on each Salt minion to view the minion key fingerprint:

            $ salt-call --local key.finger

    - Compare this value to the value that is displayed when you run the "salt-key -–finger <MINION_ID>"" command on the Salt master.

        $ salt-key --finger ubuntu-minion-01

    - Test Master Minion Communication


        - Verify the communication between the Master and a Minion by running the test.ping command:

            $ salt ubuntu-minion-01 test.ping

            - we will get the below output

            ubuntu-minion-01:
            True

        - To test the communication between Salt Master and all Minions use:

            $ salt '*' test.ping

Delete a Minion from the list:

    - Use the below command to delete a minion

        $ salt-key --delete=<minion-id>
=====================================================================================================================================================================================================================================================

What is SaltStack?

    - SaltStack is an orchestration and configuration management tool which allows the system administrators to perform automation of server management.
    - SaltStack provides high-speed data connectivity and faster communication between the different systems present in the IT organization.
    - Its multithreaded design allows the users to run thousands of tasks simultaneously.

Feature of SaltStack:

    - Fault tolerance
    - Flexible
    - Scalable Configuration Management
    - Parallel Execution model
    - Python API
    - Easy to Set Up
    - Language Agnostic

Authentication between Master and Minion:

    - Communication between the master and minions is performed over the ZeroMQ transport protocol, and all communication is encrypted with public/private keypairs.
    - A keypair is generated by a minion when Salt is first installed on it, after which the minion will send its public key to the master.
    - You will need to accept the minion’s key from the master; communication can then proceed between the two.

Remote Execution:

    - Salt offers a very wide array of remote execution modules.
    - An execution module is a collection of related functions that you can run on your minions from the master.
    - For example

        $ salt 'webserver1' npm.install gulp

        - In this command "npm" is the module and "install" is the function.
        - This command installs the Gulp Node.js package via the Node Package Manager (NPM).

    - The execution modules that Salt makes available represent system administration tasks that you would otherwise perform in a shell, including but not limited to:

        - Creating and managing system users
        - Installing and uninstalling software
        - Editing or creating configuration files

    - You can also write your own execution modules.

cmd.run:

    - The cmd.run function is used to run arbitrary commands on your minions from the master:

        $ salt '*' cmd.run 'ls -l /etc'

    - This would return the contents of /etc on each minion.

Salt-States:

    - Salt offers another way to configure a minion in which you declare the state that a minion should be in.
    - This kind of configuration is called a Salt state, and the methodology is referred to generally as configuration management.
    - Salt states are defined in state files. Once you have recorded your states, you then apply them to a minion.
    - Salt analyzes the state file and determines what it needs to do to make sure that the minion satisfies the state’s declarations.

    - Example: /srv/salt/webserver_setup.sls

        - Salt analyzes the state file and determines what it needs to do to make sure that the minion satisfies the state’s declarations.

            network_utilities:
              pkg.installed:
                - pkgs:
                  - rsync
                  - curl

            nginx_pkg:
              pkg.installed:
                - name: nginx

            nginx_service:
              service.running:
                - name: nginx
                - enable: True
                - require:
                  - pkg: nginx_pkg

        - State files end with the extension .sls (Salt State)
        - State files can have one or more state declarations, which are the top-level sections of the file (network_utilities, nginx_pkg, and nginx_service in the above example).
        - State declarations IDs are arbitrary, so you can name them however you prefer.
        - Note:

            - If you were to name the ID to be the same as the relevant installed package, then you do not need to specify the - name option, as it will be inferred from the ID.
            - For example, this snippet also installs NGINX:

                nginx:
                    pkg.installed

            - The same name/ID inference convention is true for other Salt modules.

    - State Modules:

        - State declarations contain state modules.
        - State modules are distinct from execution modules but often perform similar jobs.
        - For example, a pkg state module exists with functions analogous to the pkg execution module as with the pkg.installed state function and the pkg.install execution function.
        - As with execution modules, Salt provides a wide array of state modules for you to use.

    - State declarations are not necessarily applied in the order they appear in a state file, but you can specify that a declaration depends on another one using the require option.
    - This is the case in the above example; Salt will not attempt to run and enable NGINX until it is installed.
    - State files are really just collections of dictionaries, lists, strings, and numbers that are then interpreted by Salt.
    - By default, Salt uses the YAML syntax for representing states.
    - State files are often kept on the Salt master’s filesystem, but they can also be stored in other fileserver locations, like a Git repository

    - Applying a State to a Minion:

        - To apply a state to a minion, use the state.apply function from the master:

            $ salt `webserver1` state.apply webserver_setup

        - This command applies the example webserver_setup.sls state to a minion named webserver1
        - When applying the state, the .sls suffix is not mentioned.
        - All of the state declarations in the state file are applied.

=======================================================================================================================================================================================================================================================

SaltStack - Architecture:

    - The SaltStack Architecture is designed to work efficiently with numerous servers -  ranging from the Local Network systems to the deployment made over the various data centers
    - SaltStack Architecture is basically a Server/Client model having required functionalities which are built into the single set processes.

    - Components of SaltStack

        - Salt Master:

            - The salt master is a master daemon, this daemon is used for sending configurations and commands to the Salt Slaves.
            - A single master is capable of handling the multiple Masters.

        - Salt Minion:

            - Salt Minions are the slave daemons. Salt minions receive the configuration and commands from the master daemon.
            - The slave daemons are installed on every managed machine and configured to interact with the master daemon.
            - It is the responsibility of Salt Minion to execute the instructions sent by the salt master, report job success and provide data related to the underlying host.

        - Execution:

            - Ad-hoc commands and modules are executed against one or more salt minion from the command line which delivers real-time monitoring.

        - Formula:

            - Formulas are just collections of states that together configure an application or system component on a minion
            - Formulas are just like the open-ended Salt States and can be used for performing the task like installation of the package,  configuration of a service, set up users or permissions and many more.
            - Formulas are usually organized across several different .sls files.
            - Formulas are pre-written Salt States.
            - Salt Formulas are simple yaml text files and by default reside on your Salt Master in /srv/salt/
            - As a simple example, to install the popular Apache web server (using the normal defaults for the underlying distro) simply include the apache-formula from a top file:

                base:
                  'web*':
                    - apache

            - Each Salt Formula is an individual Git repository designed as a drop-in addition to an existing Salt State tree

            - Example:

                root@Slat-Master:/srv/salt# salt 'ubuntu-minion-01' state.sls vim
                ubuntu-minion-01:
                ----------
                          ID: vim
                    Function: pkg.installed
                      Result: True
                     Comment: All specified packages are already installed
                     Started: 03:59:10.887713
                    Duration: 1192.045 ms
                     Changes:

                Summary for ubuntu-minion-01
                ------------
                Succeeded: 1
                Failed:    0
                ------------
                Total states run:     1
                Total run time:   1.192 s
                root@Slat-Master:/srv/salt#


        - Grains:

            - Grains is an interface designed for providing the information related to Minions,  this information is static.
            - When the Salt Minion begins, Grains also get loaded which simply indicates that information available in grains cannot be changed.
            - Thus, the information in Grains could be related to the operating system for the running kernel. Grains is case sensitive.
            - Example:

                $ salt -G 'os:CentOS' pkg.install httpd

            - You can also use grains in a top file:

                base:
                  'os:CentOS':
                    - match: grain
                    - centos_setup

            - Grain information generally isn’t very dynamic, but it can change occasionally, and Salt will refresh its grain data when it does.
            - To view your minions’ grain data:

                $ salt '*' grains.items

        - Pillar:

            - A pillar is an interface designed for generating or storing the highly sensitive information specific to particular slave daemons, such as passwords and cryptographic keys.
            - Salt’s pillar feature takes data defined on the Salt master and distributes it to minions.
            - Pillar is also a useful place to store non-secret data that you wouldn’t want to record directly in your state files.
            - It stores the information in a key/value pair and the management of data is done just like salt state tree.
            - Pillar data is kept in .sls files which are written in the same YAML syntax as states
            - In addition to storing pillar data on the master, you can also keep it in other locations, like in a Git repository

            - Example: /srv/pillar/user_info.sls

                users:
                  joe:
                    shell: /bin/zsh
                  amy:
                    shell: /bin/bash
                  sam
                    shell: /bin/fish

            - As with state files, a top file (separate from your states’ top file) maps pillar data to minions
            - Salt Pillar is sometimes confused with Salt Grains, as they both keep data that is used in states and remote execution.
            - The data that grains maintains originates from the minions, while the data in pillar originates on the master (or another backend) and is delivered to the minions.

        - The Top File:

            - It is used for matching the Salt States and Pillar Data to Slave Daemons.
            - In addition to manually applying states to minions, Salt provides a way for you to automatically map which states should be applied to different minions.
            - This map is called the top file.

            - Example: /srv/salt/top.sls

                base:
                  '*':
                    - universal_setup

                  'webserver1':
                    - webserver_setup

                - "base" refers to the Salt environment.
                - You can specify more than one environment corresponding to different phases of your work;
                - for example: development, QA, production, etc.
                - base is the default.

                - Groups of minions are specified under the environment, and states are listed for each set of minions.
                - The above example top file says that a universal_setup state should be applied to all minions ('*'), and the webserver_setup state should be applied to the webserver1 minion.

            - If you run the state.apply function with no arguments, then Salt will inspect the top file and apply all states within it according to the mapping you’ve created:

                $ salt '*' state.apply

        - Runners:

            - It is a module present inside the Salt Master and responsible for performing tasks like reading data from the external APs, connection status, job status, query connected Salt Minions and many more.
            - Salt runners are convenience applications executed with the salt-run command.
            - Salt runners work similarly to Salt execution modules however they execute on the Salt master itself instead of remote Salt minions.
            - A Salt runner can be a simple client call or a complex application.
            - Example:

                $ salt-run test.foo

            - A simple runner that returns a well-formatted list of the minions that are responding to Salt calls could look like this:

                # Import salt modules
                import salt.client

                def up():
                    '''
                    Print a list of all of the minions that are up
                    '''
                    client = salt.client.LocalClient(__opts__['conf_file'])
                    minions = client.cmd('*', 'test.version', timeout=1)
                    for minion in sorted(minions):
                        print minion

        - Returners:

            - This component is responsible for returning the data from Salt Minion to the other system.
            - By default the return values of the commands sent to the Salt minions are returned to the Salt master
            - Returners pull their configuration values from the Salt minions. Returners are only configured once, which is generally at load time.
            - Example:

                $ salt '*' test.version --return redis_return

            - A returner is a Python module containing at minimum a returner function
            - The returner function must accept a single argument. The argument contains return data from the called minion function.

                import redis
                import salt.utils.json

                def returner(ret):
                    '''
                    Return information to a redis server
                    '''
                    # Get a redis connection
                    serv = redis.Redis(
                        host='redis-serv.example.com',
                        port=6379,
                        db='0')
                    serv.sadd("%(id)s:jobs" % ret, ret['jid'])
                    serv.set("%(jid)s:%(id)s" % ret, salt.utils.json.dumps(ret['return']))
                    serv.sadd('jobs', ret['jid'])
                    serv.sadd(ret['jid'], ret['id'])

            - The above example of a returner set to send the data to a Redis server serializes the data as JSON and sets it in redis.

        - Reactor:

            - Salt's Reactor system gives Salt the ability to trigger actions in response to an event

        - Salt Cloud:

            - Salt cloud provides a user with a powerful interface that helps to communicate with salt Minion.

        - SaltSSH:

            - This component is used to Run the Salt commands on Secure shell on the systems without any interference of Salt Minion.

=======================================================================================================================================================================================================================================================

Benefits of SaltStack:

    - There are a number of benefits of using the SaltStack, and they are mentioned below:

        - Robust:

            - SaltStack is a simple, powerful, robust configuration management framework which can work efficiently with thousands of systems simultaneously without hassle.

        - Authentication:

            - SaltStack supports secure authentication. It uses Secure Shell protocol for the authentication purpose.

        - Secure:

            - It maintains data security by using encrypted protocols.

        - Fast:

            - SaltStack is very lightweight, fast communication bus which is a base for the remote execution engines.

        - Virtual Machine Automation:

            - SaltStack uses Virtual Could Controller capabilities for the virtual machine automation

        - Infrastructure as data, not code:

            - SaltStack delivers model-driver configuration management, simple deployment and commands execution framework.

Introduction to ZeroMQ:
----------------------

    - SaltStack works on the ZeroMQ library
    - ZeroMQ is an embeddable networking and fast messaging library.
    - Its basic implementation is done in C or C++ and the native implementation for different languages include .Net and JAVA
    - It is a peer to peer, a brokerless messaging process which allow users to design a complex communication process in a simple manner.
    - There are five basic patterns followed by ZeroMQ:

        - Synchronous Request/Response:

            - It is used to send the request and receive the revert for every sent request

        - Asynchronous Request/Response :

            - A requestor will send the request message to start the conversation and wait for the revert.
            - A provider will wait for the incoming messages and revert back as a response message.

        - Publish/Subscribe:

            - It is used to distribute the data from a single process to different recipients.
            - For example: From Publisher to Subscribers.

        - Push/Pull:

            - It is responsible for sharing the data with all nodes connected

        - Exclusive Pair:

            - It is used to connect the two peers in order to make a pair.

    - ZeroMQ is a flexible tool which allows to exchange the messages among various clusters and multi-system environment.
    - It is a  default transport library presented in Salt.

Templates:

    - Templating allows Salt formulas and other files to be written in a more flexible manner.
    - Templates can use the information available about the minions to construct customized versions of formula or configuration files.
    - By default, Salt uses the Jinja template format, which provides substitution functionality and simple logical constructs for decision making.

    - Jinja Templates:

        - To inject pillar data into your states, use Jinja’s template syntax.
        - While Salt uses the YAML syntax for state and pillar files, the files are first interpreted as Jinja templates (by default).
        - Jinja is the default templating language in SLS files.
        - Jinja is evaluated before YAML, which means it is evaluated before the States are run.
        - The most basic usage of Jinja in state files is using control structures to wrap conditional or redundant state elements:

            tcsh:
                pkg:
                    - installed
            {% endif %}

            motd:
              file.managed:
                {% if grains['os'] == 'FreeBSD' %}
                - name: /etc/motd
                {% elif grains['os'] == 'Debian' %}
                - name: /etc/motd.tail
                {% endif %}
                - source: salt://motd

        - In this example, the first if block will only be evaluated on minions that aren't running FreeBSD, and the second block changes the file name based on the os grain.

==================================================================================================================================================================================================================================================

Examples:

    - Create a state formula to install "tree" in the minion

        - Create a file named “websetup.sls” under /srv/salt/ directory and add the following code.

            websetup.sls

                websetup:
                   pkg:
                      - installed
                      - pkgs:
                           - tree

        - Apply this Formula to Salt master using the following command

            root@Slat-Master:/srv/salt# salt 'ubuntu-minion-01' state.sls websetup
            ubuntu-minion-01:
            ----------
                      ID: websetup
                Function: pkg.installed
                  Result: True
                 Comment: The following packages were installed/updated: tree
                 Started: 14:42:31.533450
                Duration: 32306.323 ms
                 Changes:
                          ----------
                          tree:
                              ----------
                              new:
                                  1.8.0-1
                              old:

            Summary for ubuntu-minion-01
            ------------
            Succeeded: 1 (changed=1)
            Failed:    0
            ------------
            Total states run:     1
            Total run time:  32.306 s
            root@Slat-Master:/srv/salt#

    - Highstate:

        - A “highstate” is a way for Salt to determine which of the Salt Formulas should be applied to a certain minion.
        - Execute a “highstate” using the following command.

            $ salt <targets> state.highstate

    - top.sls:

        - When the minion request to execute a highstate, as mentioned before, the minion requests the top.sls from the Salt master and searches for formulas that it matches.
        - By default, this file is located at /srv/salt/top.sls.
        - Let us add our formula to the top.sls file and set "ubuntu-minion-01" as target.

            base:
               '*':
                  - common
               'ubuntu-minion-01’:
                  - websetup

        - Now, execute the highstate targeting ubuntu-minion-01 as shown below.
